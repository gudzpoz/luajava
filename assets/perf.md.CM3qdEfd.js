import{_ as e,c as n,o as s,a7 as t}from"./chunks/framework.FXXHEqG5.js";const d=JSON.parse('{"title":"Performance","description":"","frontmatter":{},"headers":[],"relativePath":"perf.md","filePath":"perf.md","lastUpdated":1767442724000}'),r={name:"perf.md"};function l(o,a,i,c,p,u){return s(),n("div",{"data-pagefind-body":!0,"data-pagefind-meta":"date:1767442724000"},[...a[0]||(a[0]=[t(`<h1 id="performance" tabindex="-1">Performance <a class="header-anchor" href="#performance" aria-label="Permalink to &quot;Performance&quot;">​</a></h1><p>This page contains some barebone benchmark data and a bit of explanation to help you understand the costs of crossing between Java and Lua boundaries.</p><h2 id="benchmark-results" tabindex="-1">Benchmark Results <a class="header-anchor" href="#benchmark-results" aria-label="Permalink to &quot;Benchmark Results&quot;">​</a></h2><p>The following benchmarks were run using <a href="https://github.com/openjdk/jmh" target="_blank" rel="noreferrer">JMH (Java Microbenchmark Harness)</a> on <code>jdk17-openjdk</code> (Linux 6.17.8 x86_64). Results are averaged over multiple iterations.</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Benchmark                                        (lua)  Mode  Cnt        Score       Error  Units</span></span>
<span class="line"><span></span></span>
<span class="line"><span>MethodCallBenchmark.benchmarkPurePcall         Lua 5.4  avgt    3       83.966 ±    25.791  ns/op</span></span>
<span class="line"><span>MethodCallBenchmark.benchmarkPurePcall          LuaJIT  avgt    3       62.959 ±     1.338  ns/op</span></span>
<span class="line"><span>MethodCallBenchmark.benchmarkPurePcall            LuaJ  avgt    3       96.250 ±    30.891  ns/op</span></span>
<span class="line"><span></span></span>
<span class="line"><span>MethodCallBenchmark.benchmarkObjectMethodCall  Lua 5.4  avgt    3      889.299 ±   116.571  ns/op</span></span>
<span class="line"><span>MethodCallBenchmark.benchmarkObjectMethodCall   LuaJIT  avgt    3      809.894 ±    34.220  ns/op</span></span>
<span class="line"><span>MethodCallBenchmark.benchmarkObjectMethodCall     LuaJ  avgt    3      456.171 ±   101.727  ns/op</span></span>
<span class="line"><span></span></span>
<span class="line"><span>MethodCallBenchmark.benchmarkModuleMethodCall  Lua 5.4  avgt    3      655.256 ±     3.893  ns/op</span></span>
<span class="line"><span>MethodCallBenchmark.benchmarkModuleMethodCall   LuaJIT  avgt    3      590.631 ±    10.637  ns/op</span></span>
<span class="line"><span>MethodCallBenchmark.benchmarkModuleMethodCall     LuaJ  avgt    3      339.211 ±    42.350  ns/op</span></span>
<span class="line"><span></span></span>
<span class="line"><span>SimpleBenchmark.benchmarkBinaryTrees           Lua 5.4  avgt    3   370316.187 ±  6141.563  ns/op</span></span>
<span class="line"><span>SimpleBenchmark.benchmarkBinaryTrees            LuaJIT  avgt    3   215069.889 ±  2591.835  ns/op</span></span>
<span class="line"><span>SimpleBenchmark.benchmarkBinaryTrees              LuaJ  avgt    3  1284857.526 ± 16054.289  ns/op</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="understanding-the-numbers" tabindex="-1">Understanding the Numbers <a class="header-anchor" href="#understanding-the-numbers" aria-label="Permalink to &quot;Understanding the Numbers&quot;">​</a></h2><h3 id="java-to-lua-call-costs" tabindex="-1">Java-to-Lua call costs <a class="header-anchor" href="#java-to-lua-call-costs" aria-label="Permalink to &quot;Java-to-Lua call costs&quot;">​</a></h3><p>The <code>benchmarkPurePcall</code> benchmarks runs two Java methods: <code>L.getGlobal(&quot;f&quot;)</code> to push a Lua function onto the Lua stack, and <code>L.pcall(0, 0)</code> to call the function. And it is the bare minimum code you need to call anything in Lua from Java.</p><p>Rewriting the code in C with a loop calling <code>lua_getglobal(...)</code> and then <code>lua_pcall(...)</code>, each iteration on my machine takes 22.396 ns/op averaged (with LuaJIT). So the Java JNI costs are mostly 2x ~ 3x pure C.</p><p>Note that the costs will go up with increased argument counts: every argument requires one JNI call to pass them over from Java to Lua.</p><h3 id="lua-to-java-costs" tabindex="-1">Lua-to-Java costs <a class="header-anchor" href="#lua-to-java-costs" aria-label="Permalink to &quot;Lua-to-Java costs&quot;">​</a></h3><p>The <code>benchmarkObjectMethodCall</code> benchmarks run Lua code like <code>big_int:intValue()</code> to test Lua-to-Java performance.</p><p>Calling from Lua to Java is slower, because Lua is dynamic while Java require static argument types. So in Lua-to-Java calls, we will need to jump back and forth between Lua and Java to determine the matching method. (This, too, is affected by the argument numbers.)</p><p>To reduce the dynamics, we provide <code>java.method</code> to look up methods by user-provided signatures, as is benchmarked by <code>benchmarkModuleMethodCall</code>. And it indeed speed up things a little bit.</p><p>We can also notice that LuaJ is quite fast in the two benchmark. It&#39;s probably because LuaJ, with all code in Java, has no cross-language boundaries or JNI costs, and JVM can optimize away some of the costs with method inlining.</p><h3 id="pure-lua-code" tabindex="-1">Pure Lua code <a class="header-anchor" href="#pure-lua-code" aria-label="Permalink to &quot;Pure Lua code&quot;">​</a></h3><p>The <code>benchmarkBinaryTrees</code> benchmarks run a binary-tree related program written in pure Lua. Unsurprisingly, LuaJIT is fastest. And it is when JNI costs are mostly marginal.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>The binary tree algorithm used here is quite recursive, which is not that friendly to LuaJIT&#39;s tracing JIT. It should have even greater speed-up with heavily looping, biased branching Lua programs.</p></div><h2 id="take-away" tabindex="-1">Take-away <a class="header-anchor" href="#take-away" aria-label="Permalink to &quot;Take-away&quot;">​</a></h2><ol><li><p>JNI calls come with a cost. They are not that costly, but things add up quickly. So take note of it if you care about performance.</p></li><li><p>LuaJIT is not specifically faster in use cases where JNI calls are used heavily. It is because LuaJIT can&#39;t optimize across C/Lua boundaries.</p></li><li><p>Under JNI-heavy use cases, LuaJ is surprisingly more performant, probably because the JVM is inlining things away.</p></li><li><p>Finally, LuaJIT is not magic. You will need to make things &quot;mostly Lua&quot; to make it perform better.</p></li></ol>`,20)])])}const m=e(r,[["render",l]]);export{d as __pageData,m as default};
