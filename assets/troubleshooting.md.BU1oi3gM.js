import{_ as a,c as s,o as t,a7 as i}from"./chunks/framework.FXXHEqG5.js";const u=JSON.parse('{"title":"Troubleshooting","description":"","frontmatter":{},"headers":[],"relativePath":"troubleshooting.md","filePath":"troubleshooting.md","lastUpdated":1767442724000}'),n={name:"troubleshooting.md"};function o(r,e,l,h,d,p){return t(),s("div",{"data-pagefind-body":!0,"data-pagefind-meta":"date:1767442724000"},[...e[0]||(e[0]=[i(`<h1 id="troubleshooting" tabindex="-1">Troubleshooting <a class="header-anchor" href="#troubleshooting" aria-label="Permalink to &quot;Troubleshooting&quot;">â€‹</a></h1><h2 id="string-messed-up" tabindex="-1">String Messed Up? <a class="header-anchor" href="#string-messed-up" aria-label="Permalink to &quot;String Messed Up?&quot;">â€‹</a></h2><p>Java uses <a href="http://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8" target="_blank" rel="noreferrer">its own modified UTF-8 encoding</a> for JNI <code>GetStringUTFChars</code>. It should be more efficient for characters within the basic plane (<code>0 - 0xFFFF</code>), but uses a different kind of encoding for characters higher up.</p><p>Currently, we still use <code>GetStringUTFChars</code> for most the String conversions. And that means things can be problematic if your string contains emojis, for example. A workaround for this is to use the buffer API to directly push raw strings:</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.nio.ByteBuffer;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.nio.charset.StandardCharsets;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Lua L, String string) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    L.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ByteBuffer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wrap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ðŸ€„&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getBytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(StandardCharsets.UTF_8)));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>On some old Android API versions (reproduced on Android API 21 (a.k.a., Android 5)), decoding valid UTF-8 strings containing out-of-plane characters can crash the application... This is not ideal, but I guess we will have to live with it for now.</p></div><h2 id="class-or-resource-not-found" tabindex="-1">Class (or Resource) Not Found <a class="header-anchor" href="#class-or-resource-not-found" aria-label="Permalink to &quot;Class (or Resource) Not Found&quot;">â€‹</a></h2><h3 id="is-a-wrong-classloader-used" tabindex="-1">Is a wrong classloader used? <a class="header-anchor" href="#is-a-wrong-classloader-used" aria-label="Permalink to &quot;Is a wrong classloader used?&quot;">â€‹</a></h3><p>By default, LuaJava tries the following classloaders for class loading, and chooses the first non-null one:</p><ol><li><code>Thread.currentThread().getContextClassLoader()</code></li><li><code>party.iroiro.luajava.util.ClassUtils.class.getClassLoader()</code></li><li><code>ClassLoader.getSystemClassLoader()</code></li></ol><p>This might not be optimal if your class loading environment is not set up in this hierarchical way. You may override <code>party.iroiro.luajava.util.ClassUtils#DEFAULT_CLASS_LOADER</code> to use a different class loader. (It is not documented in the Javadoc, since it is quite internal and subject to changes.)</p><h3 id="are-you-mistakenly-using-java-9-modules" tabindex="-1">Are you (mistakenly) using Java 9 modules? <a class="header-anchor" href="#are-you-mistakenly-using-java-9-modules" aria-label="Permalink to &quot;Are you (mistakenly) using Java 9 modules?&quot;">â€‹</a></h3><p>If you package a fat JAR with, for example, <a href="https://github.com/GradleUp/shadow" target="_blank" rel="noreferrer">shadow</a>, please note that older versions of the plugins may not prune the <code>module-info.class</code> from some of your dependencies, potentially making the whole JAR a large module.</p><p>It should be fine if the fat JAR is the only external JAR you load into the JVM. But, if you plan to use this JAR as part of another application (e.g., as a plugin), this can cause problems because the module system can restrict reflective access. Try moving all <code>**/*/module-info.class</code> from your fat JAR.</p><h2 id="jvm-crashed" tabindex="-1">JVM Crashed <a class="header-anchor" href="#jvm-crashed" aria-label="Permalink to &quot;JVM Crashed&quot;">â€‹</a></h2><p>The crash is often followed by the following error message:</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#</span></span>
<span class="line highlighted"><span># A fatal error has been detected by the Java Runtime Environment:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span>#  SIGSEGV (0xb) at pc=0x0000...</span></span>
<span class="line"><span>#</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>This is very likely a bug in this library. But if you are using the natives <code>Lua**Natives</code> directly, you might want to take note of the following:</p><h3 id="have-you-pushed-too-many-values-onto-the-stack" tabindex="-1">Have you pushed too many values onto the stack? <a class="header-anchor" href="#have-you-pushed-too-many-values-onto-the-stack" aria-label="Permalink to &quot;Have you pushed too many values onto the stack?&quot;">â€‹</a></h3><p>Lua imposes an initial stack size and an upper limit. You need to <code>lua_checkstack</code> (<code>Lua::checkStack(int extra)</code>)to allocate more stack slots.</p><p>When going beyond the current stack size, Lua just overwrites any data going after the stack without any notice, which will very likely result in all kinds of memory corruption.</p><p>We try to call <code>checkStack</code> for every stack incrementing operation. If we miss any, you are welcome to report it. But if you are using the <code>Lua**Natives</code> directly, you are on your own.</p><h3 id="a-message-like-fatal-error-in-native-method" tabindex="-1">A message like <code>FATAL ERROR in native method: ...</code> <a class="header-anchor" href="#a-message-like-fatal-error-in-native-method" aria-label="Permalink to &quot;A message like \`FATAL ERROR in native method: ...\`&quot;">â€‹</a></h3><p>It means Lua captured the error, but had no way to recover from it. For example:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>FATAL ERROR in native method: error in __gc metamethod (stack overflow)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>This might be caused by Lua&#39;s untimely GC. When you push a value right when the stack is nearly full (the maximum slots should be over several thousand), Lua might decide that it is time for garbage collection, which might call a <code>__gc</code> metamethod, which then overflows the stack.</p><p>Try to keep the number of items in stack lower than a thousand, and you will be safe.</p><h3 id="have-you-mistaken-the-type-of-some-element" tabindex="-1">Have you mistaken the type of some element? <a class="header-anchor" href="#have-you-mistaken-the-type-of-some-element" aria-label="Permalink to &quot;Have you mistaken the type of some element?&quot;">â€‹</a></h3><p>For example, if you try to <code>rawGetI</code> on a <em><strong>boolean</strong></em>, <em><strong>number</strong></em> or any other type that is <em><strong>not a table</strong></em>, the program <em>will</em> crash. We do not check the type for you, neither does Lua.</p>`,29)])])}const m=a(n,[["render",o]]);export{u as __pageData,m as default};
